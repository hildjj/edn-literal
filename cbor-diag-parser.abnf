seq             = S [item S *("," S item S) OC] S
one-item        = S item S
item            = map / array / tagged
                / number / simple
                / string / streamstring

string1         = (tstr / bstr) spec
string1e        = string1 / ellipsis
ellipsis        = 3*"." ; "..." or more dots
string          = string1e *(S string1e)

number          = (hexfloat / hexint / octint / binint
                   / decnumber / nonfin) spec
sign            = "+" / "-"
decnumber       = [sign] (1*DIGIT ["." *DIGIT] / "." 1*DIGIT)
                         ["e" [sign] 1*DIGIT]
hexfloat        = [sign] "0x" (1*HEXDIG ["." *HEXDIG] / "." 1*HEXDIG)
                         "p" [sign] 1*DIGIT
hexint          = [sign] "0x" 1*HEXDIG
octint          = [sign] "0o" 1*ODIGIT
binint          = [sign] "0b" 1*BDIGIT
nonfin          = %s"Infinity"
                / %s"-Infinity"
                / %s"NaN"
simple          = %s"false"
                / %s"true"
                / %s"null"
                / %s"undefined"
                / %s"simple(" S item S ")"
uint            = "0" / DIGIT1 *DIGIT
tagged          = uint spec "(" S item S ")"

app-prefix      = lcalpha *lcalnum ; including h and b64
                / ucalpha *ucalnum ; tagged variant, if defined
sqstr           = SQUOTE *single-quoted SQUOTE
bstr            = embedded / sqstr / known-app-str / ext-app-str
ext-app-str     = app-prefix sqstr
known-app-str   = h / b64 / ip / dt

invalid-app-str = *single-quoted ; error parsing the grammar of this app-str

; app-string h
h               = %s"h" SQUOTE inside-h SQUOTE
inside-h        = valid-h / invalid-app-str
valid-h         = SQS *(HEXDIG SQS HEXDIG SQS / ellipsis SQS) SQS

; app-string b64
b64             = %s"b64" SQUOTE inside-b64 SQUOTE
inside-b64      = valid-b64 / invalid-app-str
valid-b64       = B *b64-4  [ b64-3 / b64-2 ]
b64-4           = 4(b64dig B)
b64-3           = 3(b64dig B) ["="] B
b64-2           = 2(b64dig B) ["=" B "="] B
b64dig          = ALPHA / DIGIT / "-" / "_" / "+" / "/"
B               = *iblank *(sq-hash-comment *iblank)
iblank          = LF / SPACE  ; Not HT or CR (gone)

; app-string dt
dt              = (%s"dt" / %s"DT") SQUOTE inside-dt SQUOTE
inside-dt       = date-time / invalid-app-str
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset
date-time       = full-date "T" full-time
date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap sec
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]

; app-string ip
ip              = (%s"ip" / %s"IP") SQUOTE inside-ip SQUOTE
inside-ip       = valid-ip / invalid-app-str
valid-ip        = IPaddress [SLASH uint]
IPaddress       = IPv4address/ IPv6address

; ABNF from RFC 3986, re-arranged for PEG compatibility:
IPv6address     =                            6( h16 ":" ) ls32
                /                       "::" 5( h16 ":" ) ls32
                / [ h16               ] "::" 4( h16 ":" ) ls32
                / [ h16 *1( ":" h16 ) ] "::" 3( h16 ":" ) ls32
                / [ h16 *2( ":" h16 ) ] "::" 2( h16 ":" ) ls32
                / [ h16 *3( ":" h16 ) ] "::"    h16 ":"   ls32
                / [ h16 *4( ":" h16 ) ] "::"              ls32
                / [ h16 *5( ":" h16 ) ] "::"              h16
                / [ h16 *6( ":" h16 ) ] "::"

h16             = 1*4HEXDIG
ls32            = ( h16 ":" h16 ) / IPv4address
IPv4address     = doctet "." doctet "." doctet "." doctet
doctet          = "25" %x30-35         ; 250-255
                / "2" %x30-34 DIGIT    ; 200-249
                / "1" 2DIGIT           ; 100-199
                / %x31-39 DIGIT        ; 10-99
                / DIGIT                ; 0-9


tstr            = DQUOTE *double-quoted DQUOTE
embedded        = "<<" seq ">>"

array           = "[" spec S [item S *("," S item S) OC] "]"
map             = "{" spec S [kp S *("," S kp S) OC] "}"
kp              = item S ":" S item

; We allow %x09 HT in prose, but not in strings
blank           = HTAB / CR / LF / SPACE
S               = *blank *(comment *blank)
; SQS is whitespace/comments inside some single quoted strings
SQS              = *blank *(sq-comment *blank)
comment          = slash-comment / hash-comment
sq-comment       = sq-slash-comment / sq-hash-comment
slash-comment    = SLASH *non-slash SLASH
hash-comment     = HASH *non-lf LF
sq-slash-comment = SLASH *sq-non-slash SLASH
sq-hash-comment  = HASH *sq-non-lf LF
non-slash        = sq-non-slash / SQUOTE
sq-non-slash     = always-safe / LF / DQUOTE / slash-escaped
non-lf           = sq-non-lf / SQUOTE
sq-non-lf        = always-safe / SLASH / DQUOTE / hash-escaped

; Note that no other C0 characters are allowed, including %x09 HT
always-safe     =  LF
                 / CR ; carriage return -- ignored on input
                 / %x20-21   ; omit 0x22 "
                 / %x23-26   ; omit 0x27 '
                 / %x28-2E   ; omit 0x2F /
                 / %x30-5B   ; omit 0x5C \
                 / %x5D-D7FF ; skip surrogate code points
                 / %xE000-10FFFF
slash-escaped   = "\" ( SQUOTE / SLASH / escapable )
hash-escaped    = "\" ( SQUOTE / "\" )

; optional trailing comma (ignored)
OC              = ["," S]

; check semantically that strings are either all text or all bytes
; note that there must be at least one string to distinguish
streamstring    = "(_" S string S *("," S string S) OC ")"
spec            = ["_" *wordchar]

double-quoted   = always-safe
                / LF
                / SLASH
                / SQUOTE
                / "\" DQUOTE
                / "\" escapable

single-quoted   = always-safe
                / LF
                / SLASH
                / DQUOTE
                / "\" SQUOTE
                / "\" escapable

escapable       = %s"b" ; BS backspace U+0008
                / %s"f" ; FF form feed U+000C
                / %s"n" ; LF line feed U+000A
                / %s"r" ; CR carriage return U+000D
                / %s"t" ; HT horizontal tab U+0009
                / "\"   ; \ backslash (reverse solidus) U+005C
                / (%s"u" hexchar) ;  uXXXX      U+XXXX

hexchar         = "{" (1*"0" [ hexscalar ] / hexscalar) "}"
                / non-surrogate
                / (high-surrogate "\" %s"u" low-surrogate)
non-surrogate   = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG)
                / ("D" ODIGIT 2HEXDIG )
high-surrogate  = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate   = "D" ("C"/"D"/"E"/"F") 2HEXDIG
hexscalar       = "10" 4HEXDIG / HEXDIG1 4HEXDIG
                / non-surrogate / 1*3HEXDIG

HTAB            = %x09    ; HT (horizontal tabulation)
LF              = %x0A    ; LF (Line Feed)
CR              = %x0D    ; CR (Carriange Return)
SPACE           = %x20    ; SPACE
DQUOTE          = %x22    ; " double quote
HASH            = %x23    ; # octothorpe
SQUOTE          = %x27    ; ' single quote
SLASH           = %x2F    ; / forward slash

DIGIT           = %x30-39 ; 0-9
DIGIT1          = %x31-39 ; 1-9
ODIGIT          = %x30-37 ; 0-7
BDIGIT          = %x30-31 ; 0-1
HEXDIG          = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
HEXDIG1         = DIGIT1 / "A" / "B" / "C" / "D" / "E" / "F"
; Note: double-quoted strings as in "A" are case-insensitive in ABNF
lcalpha         = %x61-7A ; a-z
lcalnum         = lcalpha / DIGIT
ucalpha         = %x41-5A ; A-Z
ucalnum         = ucalpha / DIGIT
ALPHA           = lcalpha / ucalpha
wordchar        = "_" / ALPHA / DIGIT ; [_a-zA-Z0-9]
